# Dynamic Programming

**INDEX**
- [개요](#개요)
- [피보나치 수열](#피보나치-수열-dp-문제-예시)
- [코딩 테스트에서 DP](#코딩-테스트에서-dp)
---

## 개요

- 연산 속도와 메모리 공간을 최대한 활용할 수 이쓴 효율적인 알고리즘을 작성해야한다. 다만 어떤 문제는 메모리 공간을 약간 더 사용하여 연산 속도를 비약적으로 증가시킬 수 있다.

- 메모리 공간을 사용하고 연산 속도를 비약적으로 향상시키는 방법에는 다이나믹 프로그래밍(동적 계획법)이 있다. 

- 해당 장에서는 DP의 2가지 방식(탑다운, 바텀업)을 이해하고, 자주 사용되는 메모이제이션 기법에 대해 알아 본다.

## 피보나치 수열 (DP 문제 예시)

- **재귀로 구현한 피보나치 수열**
    ```python
    def fibo(x):
        if x==1 or x==2: return 1
        return fibo(x-1)+fibo(x-2)
    ```
    - 위와 같이 재귀로 구현된 피보나치 수열의 문제점은 n이 커지면 커질수록 수행시간이 기하급수적으로 늘어난다. 이는 `O(2^N)`의 시간 복잡도를 갖기에 N=30 인 경우 약 10억 가량의 연산을 수행해야 한다.

    - 이러한 문제가 발생하는 이유는 계산한 함수를 계속 호출하기에 발생한다. 즉 f(n)에서 n이 커지면 커질수록 반복 호출 횟수가 많아진다.

    - 해당 문제의 경우 다이나믹 프로그래밍을 활용하면 효율적인 문제 해결이 가능하다. 다만 다음의 조건을 만족할 때 DP를 활용해야 한다.

        > 1. 큰 문제를 작은 문제로 나룰 수 있다.
        > 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

    - 따라서 피보나치 수열 문제를 DP의 기법 중 하나인 메모이제이션 기법으로 풀 수 있다. 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, *한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법*을 의미한다. 메모이제이션은 값을 저장하는 방법이므로 `캐싱`이라고도 한다.

- **DP로 구현한 피보나치 수열**

    ```python
    # 메모이제이션을 적용한 재귀 호출 (탑다운)
    d = [0]*100

    def pibo(x):
        if x==1 or x==2: return 1
        if d[x]!=0: return d[x]
        d[x] = pibo(x-1) + pibo(x-2)
        return d[x]

    # 피보나치 반복문 구현 (바텀업)

    d = [0]*100

    d[1], d[2], n = 1, 1, 99

    for i in range(3, n+1):
        d[i] = d[i-1] + d[i-2]

    print(d[n])
    ```

    - 탑다운 방식과 바텀업 방식에 대해서는 다음과 같이 말할 수 있다.

        > 1. 탑다운(Top-Down): 큰 문제 해결을 위해 작은 문제를 호출
        > 2. 바텀업(Bottom-Up): 작은 문제부터 차근차근 답을 도출하는 방식

    - 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미하므로, 다이나믹 프로그래밍과는 별개의 개념이다. 한 번 계산된 결과를 어딘가에 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다.

## 코딩 테스트에서 DP

- 문제를 푸는 첫 번째 단계는 다이나믹 프로그래밍 유형임을 파악하는 것이다. 특정 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인하다.

- 또한 가능하다면 재귀함수를 이용하는 탑다운 방식보다는 바텀업 방식으로 구현하는 것이 좋다. 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문이다.